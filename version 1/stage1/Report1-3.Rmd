---
title: "Report1-3"
author: "Mia, Junyi"
date: "2025-09-15"
output:
  html_document:
    code_folding: hide
---

```{r setup, message=FALSE, warning=FALSE}
library(dplyr)
library(knitr)
library(purrr)
library(naniar)
library(ggplot2)
library(tidyverse)
library(janitor)
library(skimr)
library(caret)
library(kableExtra)
library(lubridate)
library(factoextra)
library(stringr)
library(scales)
library(gridExtra)
library(reshape2)
orig_data = read.csv("datasets/listings.csv")
```

# Define the Problem

**The research question for this project is:** To what extent can Airbnb listing characteristics be utilized to determine, within a three-monthforward-looking window, the month that exhibits the maximum number of available days?

**Problem as a Classification Task:** This study treats the task as supervised multi-class classification, with the outcome identifying which of the next three months has the most available days (First-month, Second-month, Third-month, or Indeterminate outcome). Predictors include general listing attributes, room characteristics, and host factors, supporting systematic forecasts of short-term availability.

**Relevance to Sydney and Australia:** In Sydney’s strongly seasonal short-term rental market, early post-publication availability shapes both tourism capacity and housing pressure. Predicting at posting which of the first three months will have the highest available days clarifies supply dynamics and host behavior. These insights support evidence-based policy in New South Wales and Australia on balancing tourism with housing affordability.

# Describe the Data

```{r Describe the Data, message=FALSE, warning=FALSE}
observations = dim(orig_data)[1]
variables = dim(orig_data)[2]
numeric = sum(sapply(orig_data, is.numeric)) 
integer = sum(sapply(orig_data, is.integer)) 
double = sum(sapply(orig_data, is.double)) 
categorical = sum(sapply(orig_data, is.character)) 
logical = sum(sapply(orig_data, is.logical))
cate_total = categorical + logical
uniques <- sapply(orig_data, function(x) n_distinct(x, na.rm = TRUE))
maxunique <- max(uniques)
maxuniquename <- names(uniques)[which.max(uniques)]
overall_missing_pct <- round((sum(is.na(orig_data))/(nrow(orig_data)*ncol(orig_data)))*100,2)
miss_by_var <- data.frame(
  variable = names(orig_data),
  n_missing = colSums(is.na(orig_data))) %>%
  mutate(
    pct_missing = round(100 * n_missing / nrow(orig_data), 2)) %>%
  arrange(desc(pct_missing))
total_missing_cells <- sum(miss_by_var$n_missing)
miss_conc <- miss_by_var %>%
  mutate(prop = n_missing / total_missing_cells, cum_prop = cumsum(prop))
k_vals <- c(3, 5, 10)
topk_cover <- lapply(k_vals, function(k){
  tibble(
    k = k,
    topk_cum_pct_of_all_missing = round(100 * miss_conc$cum_prop[k], 2),
    topk_vars = paste(miss_conc$variable[seq_len(min(k, nrow(miss_conc)))], collapse = ", "))}) %>% bind_rows()
thresh <- c('>50' = 50, '>20' = 20, '>10' = 10, '>5' = 5, '>1' = 1)
thresh_tbl <- tibble(
  threshold_pct = names(thresh),
  n_vars = sapply(unname(thresh), function(t) sum(miss_by_var$pct_missing > t)))
n_zero_missing <- sum(miss_by_var$n_missing == 0)
```

## Data Source

The dataset for comes from Inside Airbnb(Inside Airbnb, 2025), an independent project that collects and publishes Airbnb data on housing impacts. The data are obtained through web scraping and are publicly accessible. For this study, we use the detailed listings data for Sydney, New South Wales, dated 10 June 2025.

## Data Description
The Sydney Airbnb dataset contains `r observations` observations and `r variables` variables, making it a tall dataset with more listings than attributes. Of these, `r numeric` variables are numeric (`r integer` integer and `r double` double), and `r cate_total` are categorical, including `r logical` logical variables. This mix of quantitative and qualitative features provides a solid basis for classification. Categorical variables differ greatly in cardinality. Some are binary, while others have many unique levels, with up to `r maxunique` categories (e.g., `r maxuniquename`). None of the variables show zero variance, ensuring that each contributes some differentiation across listings. The dataset has an overall missing rate of `r overall_missing_pct`%. Only `r n_zero_missing` variables are fully complete, while the rest contain varying degrees of missingness. The top `r topk_cover$k[1]` most incomplete variables account for `r topk_cover$topk_cum_pct_of_all_missing[1]`% of all missing values, and the top `r topk_cover$k[2]` together cover `r topk_cover$topk_cum_pct_of_all_missing[2]`%. In severity, `r thresh_tbl$n_vars[thresh_tbl$threshold_pct=='>20']` variables have more than 20% missingness, and `r thresh_tbl$n_vars[thresh_tbl$threshold_pct=='>10']` exceed 10%. Overall, the dataset is large in scale (over 10,000 observations), messy due to missingness, and supports a multi-class classification problem—making it both challenging and rich for analysis.  

## Outcome Variable

The outcome variable is defined as a categorical measure indicating which of the next three months records the highest number of available days for a given Airbnb listing. It consists of four mutually exclusive categories: First-month, Second-month, and Third-month, representing cases where the maximum availability occurs in the first, second, or third month respectively, and Indeterminate outcome, which captures cases where no single month clearly dominates in availability. This multi-class outcome enables systematic modeling of short-term temporal variation in listing availability.

## Data Challenges

The dataset contains a large number of variables, resulting in high dimensionality that complicates both exploration and modelling. In particular, the presence of high-cardinality categorical variables (e.g., `listing_url` and `amenities`) risks inflating dimensionality without contributing meaningful predictive value. The coexistence of heterogeneous data types further necessitates careful preprocessing to ensure model compatibility and reliable downstream analysis.

# Clean and Prepare the Data

```{r Clean and Prepare the Data, warning=FALSE}
set.seed(5003)

#Step0 Drop the irrelevant columns

#Drop the columns which are irrelevant for prediction, sensitive, redundant, or unusable.
DROP <- c("scrape_id","host_name", "host_about", "host_thumbnail_url", "host_picture_url", "host_id","id", "listing_url", "name", "description", "picture_url", "host_url", "host_neighbourhood", "availability_eoy", "number_of_reviews_ly", "estimated_occupancy_l365d", "estimated_revenue_l365d", "source", "host_response_time", "host_response_rate", "host_is_superhost", "host_verifications", "host_has_profile_pic", "host_identity_verified","neighbourhood", "amenities","calendar_updated", "calendar_last_scraped","review_scores_rating", "review_scores_accuracy","review_scores_cleanliness", "review_scores_checkin","review_scores_communication", "accommodates",  "review_scores_location","review_scores_value","property_type", "calendar_updated", "minimum_minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "minimum_nights_avg_ntm", "maximum_nights_avg_ntm","neighbourhood_group_cleansed", "host_listings_count", "calculated_host_listings_count_entire_homes", "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "last_review", "host_tenure", "listing_age" , "bathrooms_text", "host_location","host_since", "first_review","number_of_reviews_ltm" ,"number_of_reviews_l30d", "last_scraped","license","has_availability", "availability_365", "minimum_nights", "host_total_listings_count", "instant_bookable", "month1","month2","month3","availability_30","availability_60","availability_90")

step1 <- orig_data %>%
  
# step1 Clean and engineer multiple features
  
  # Fill bathrooms from bathrooms_text if missing; "half"=0.5 else extract number
  mutate(bathrooms = coalesce(bathrooms,case_when(str_detect(bathrooms_text, regex("half", ignore_case = TRUE)) ~ 0.5,TRUE ~ as.numeric(str_extract(bathrooms_text, "\\d+(?:\\.\\d+)?")))),
         
    # Parse dates to Date objects
    host_since = ymd(host_since),
    first_review = ymd(first_review),
    last_scraped = ymd(last_scraped),
  
    # Calculate host tenure and listing age in days
    host_tenure = as.numeric(last_scraped - host_since, units = "days"),
    listing_age = as.numeric(last_scraped - first_review, units = "days"),
    
    # Neighborhood overview: 1 if non-empty, else 0
    neighborhood_overview = ifelse(!is.na(neighborhood_overview) & neighborhood_overview != "", 1, 0),
    host_acceptance_rate = as.numeric(str_remove(host_acceptance_rate, "%")),
    
    # Remove "%", "$" and convert to numeric
    price = as.numeric(str_remove(price, "[$]")))
  
  
# step 2 sanity check and filtering stage
step2 <- step1 %>%
  filter(across(.cols = where(is.numeric) & !c("longitude", "latitude"), .fns  = ~ is.na(.x) | .x >= 0),# Keep only non-negative numeric values (except lat/long)
    price > 0,                               # Require positive price
    host_tenure >= listing_age,              # Ensure host tenure >= listing age       
    str_detect(host_location, "Australia"),  # Host must be located in Australia
    license != "",                           # License field must not be empty
    price != "",                             # Price field must not be blank
    has_availability != "",                  # Availability field must not be blank
    bathrooms != 0)                   

# step 3
cleaned_data <- step2 %>%
  # Create monthly availability windows
  mutate(
    month1 = availability_30,                        # Availability in the first 30 days
    month2 = availability_60 - availability_30,      # Availability in days 31–60
    month3 = availability_90 - availability_60) %>%       # Availability in days 61–90
  rowwise() %>%
  # Define outcome category based on the month with maximum availability
  mutate(
    outcome = {
      vals <- c(month1, month2, month3)              # Collect availability values
      max_val <- max(vals, na.rm = TRUE)             # Find maximum availability
      if (sum(vals == max_val, na.rm = TRUE) > 1) {  # If tie across months
        "Indeterminate"                              # → Assign as Indeterminate
      } else {
        which_max <- which.max(vals)                 # Otherwise, get index of max
        c("First-month", "Second-month", "Third-month")[which_max]}}) %>%  # Map to category
  ungroup() %>%  # Return to ungrouped data frame

# step 4  
  select(-any_of(DROP)) # Drop all columns listed in DROP
```

### Step0 Drop the irrelevant columns
In the initial preprocessing stage, variables irrelevant for prediction, sensitive, or redundant were removed to streamline the dataset and reduce bias. These include unique identifiers (`id`, `scrape_id`), free-text fields (`name`, `description`, `host_about`), URLs and images (`listing_url`, `picture_url`), geographic coordinates (`latitude`, `longitude`), and host personal details (`host_name`, `host_url`, `host_location`). Redundant features such as the `review_scores_xxx` family and `property_type` (overlapping with `room_type`) were also discarded. While this summary outlines the main categories, the full list of dropped variables is preserved in the code for transparency and reproducibility.  

### Step 1: Initial Cleaning and Feature Engineering
Bathroom counts are standardised using `bathrooms_text`, mapping “half” to 0.5 and extracting numeric values where available. Date variables (`host_since`, `first_review`, `last_scraped`) are converted into proper formats to derive `host_tenure` and `listing_age` as measures of host experience and listing longevity. Other fields are cleaned for consistency: `neighbourhood_overview` is recoded as a binary indicator (1 if non-empty, 0 otherwise), `host_acceptance_rate` is converted from percentages to numeric, and `price` is stripped of the dollar sign before numeric conversion. These steps ensure consistent data types, introduce temporal features, and create interpretable numeric variables for subsequent analysis.  


### Step2 Sanity check and filtering stage
Several filters were applied to ensure logical and regulatory consistency. Numeric variables (except `longitude` and `latitude`) were restricted to non-negative values, with `price` required to be strictly positive. Temporal validity was enforced by requiring `host_tenure ≥ listing_age`. Listings were retained only if `host_location` contained “Australia” and both `license` and `has_availability` were non-empty(Airbnb. (n.d.)). The bathrooms values below zero were removed in line with New South Wales regulations (2010). In total, `r dim(orig_data)[1]-dim(step2)[1]` listings were excluded, improving data coherence and policy alignment.

### Step3 Outcome construction, and missingness handling
Forward availability is recasted into three non-overlapping windows (0–30, 31–60, 61–90 days). For each listing, the window with the most available days defines the outcome; ties are labelled Indeterminate. This yields a four-class target (First-month, Second-month, Third-month, Indeterminate) that directly operationalises the timing of peak availability.

### Step4 Column removal for data simplification
Irrelevant and sensitive fields such as IDs, text descriptions, URLs, geographic coordinates, redundant review scores, and host personal details are removed. This streamlines the dataset by retaining only variables useful for constructing the outcome and predictive features.


# Reference
Airbnb. (n.d.). *What are the requirements to be a host?* Retrieved from <https://www.airbnb.com.au/help/article/2922>
Inside Airbnb. (2025). *Inside Airbnb - Data source.* Retrieved from <http://insideairbnb.com>
New South Wales Government. (2010). *Residential Tenancies Act 2010, Section 52.* Retrieved from <https://legislation.nsw.gov.au/view/html/inforce/current/act-2010-042#sec.52>

